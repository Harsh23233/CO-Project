import sys
def twos_complement_binary_to_decimal(binary):
    if binary[0] == '1': # If the number is negative
        # Invert all bits
        inverted = ''.join('1' if bit == '0' else '0' for bit in binary)
        # Add 1 to the inverted number
        binary = bin(int(inverted, 2) + 1)[2:].zfill(len(binary))
        # Convert the binary number to decimal
        decimal = -int(binary, 2)
    else:
        decimal = int(binary, 2)
    return decimal

def sign_extend(value, bits):
    sign_bit = value[0]
    if sign_bit == '1':
        value = value[0] * (32 - bits) + value
    else:
        value = '0' * (32 - bits) + value
    return value

def decimal_to_binary(n, length):
        return format(n if n >= 0 else (1 << length) + n, f'0{length}b')
regs = {
    'PC' : 0,
    '00000' : 0, '00001' : 0, '00010' : 0, '00011' : 0, '00100' : 0,
    '00101' : 0, '00110' : 0, '00111' : 0, '01000' : 0, '01000' : 0,
    '01001' : 0, '01010' : 0, '01011' : 0, '01100' : 0, '01101' : 0,
    '01110' : 0, '01111' : 0, '10000' : 0, '10001' : 0, '10010' : 0,
    '10011' : 0, '10100' : 0, '10101' : 0, '10110' : 0, '10111' : 0,
    '11000' : 0, '11001' : 0, '11010' : 0, '11011' : 0, '11100' : 0,
    '11101' : 0, '11110' : 0, '11111' : 0
}

rtype=['0110011']
itype = ['0000011','0010011','0010011','1100111']
stype = ['0100011']
btype=['1100011']
utype=["0010111","0110111"]
jtype=["1101111"]
valid_instructions = True

def r_type(line):
    global regs
    rs2=line[7:12]
    rs1=line[12:17]
    rd=line[-12:-7]
    if(line[0:7]=='0000000'):
        if(line[-15:-12]=='000'):
            regs[rd]=regs[rs1]+regs[rs2]
        elif(line[-15:-12]=='001'):
            rs2 = decimal_to_binary(regs[rs2],32)
            rs2=rs2[-5:]
            rs2=int(rs2,2)
            regs[rd]=regs[rs1]<<rs2
        elif(line[-15:-12]=='010'):
            if(regs[rs1]<regs[rs2]):
                regs[rd]=1
            else:
                regs[rd]=0
        elif(line[-15:-12]=='011'):
            rs1=decimal_to_binary(regs[rs1],32)
            rs1=int(rs1,2)
            rs2=decimal_to_binary(regs[rs1],32)
            rs2=int(rs2,2)
            if(rs1<rs2):
                regs[rd]=1
            else:
                regs[rd]=0
        elif(line[-15:-12]=='100'):
            regs[rd]=(regs[rs1])^(regs[rs2])
        elif(line[-15:-12]=='101'):
            rs2 = decimal_to_binary(regs[rs2],32)
            rs2=rs2[-5:]
            rs2=int(rs2,2)
            regs[rd]=regs[rs1]>>rs2
        elif(line[-15:-12]=='110'):
            regs[rd]=regs[rs1]|regs[rs2]
        elif(line[-15:-12]=='111'):
            regs[rd]=regs[rs1]&regs[rs2]
    else:
        regs[rd]=regs[rs1]-regs[rs2]

def s_type(line):
    global regs
    regs[line[7:12]]=regs[str(decimal_to_binary(regs[line[12:17]]+twos_complement_binary_to_decimal(line[0:7]+line[20:25]),5))]   #rs2 = mem(rs1 + imm)
    
def i_type(line):
    global regs
    opcode = line[-7:]
    if(opcode == '0000011'):  #lw
        regs[line[20:25]]=regs[str(decimal_to_binary(regs[line[12:17]]+twos_complement_binary_to_decimal(line[0:12]),5))]   #rs2 = mem(rs1 + imm)
    if(opcode == '0010011' and line[17:20]=='000'):   #addi
        regs[line[20:25]] = regs[line[12:17]]+twos_complement_binary_to_decimal(line[0:12])    #rs2 = rs1+imm
    if(opcode == '0010011' and line[17:20]=='011'):  #sltiu
        if(int(decimal_to_binary(regs[line[12:17]]),2)<int(line[0:12]),2):   #if unsigned(rs1)<unsigned(imm)
            regs[line[20:25]] =1
    if(opcode == '1100111'):   #jalr
        regs[line[20:25]]=regs['PC']+4    #store ret address in rd
        regs['PC'] = decimal_to_binary(regs['PC'],32)[0:31]+'0'    #before jumping LSB of PC = 0
        regs['PC'] = regs[line[12:17]]+twos_complement_binary_to_decimal(line[0:12])    #updata PC

def u_type(line):
    global regs
    #lui
    if line[-7:]=="0110111":
        #Extracting dest reg and immediate from instruction
        rd=line[-12:-7]
        imm=line[:-12]
        #Extending immediate according to instruction semantics
        while len(imm)<32:
            imm+='0'
        #Converting immediate to int and writing it on the specified reg
        imm=twos_complement_binary_to_decimal(imm)
        regs[rd]=imm
    else:
        #Extracting dest reg and immediate from instruction
        rd=line[-12:-7]
        imm=line[:-12]
        #Extending immediate according to instruction semantics
        while len(imm)<32:
            imm+='0'
        #Converting immediate to int and writing it on the specified reg
        imm=twos_complement_binary_to_decimal(imm)
        regs[rd]=regs['PC']+imm

def j_type(line):
    global regs
    global i
    #Extracting dest reg and immediate from instruction
    rd=line[-12:-7]
    imm=line[0]+line[-19:-12]+line[-20]+line[1:-20]+"0"
    #Saving the return address in dest reg
    regs[rd]=regs["PC"]+4
    #Adding the offset to PC and i
    imm=twos_complement_binary_to_decimal(imm)
    regs["PC"]+=imm
    i+=imm//4

def b_type(instruction):
    global regs
    #extracting immediate
    imm = sign_extend(instruction[0] + instruction[24:25] + instruction[1:7] + instruction[20:24] + '0', 13)
    #extracting registers
    rs2 = regs[instruction[7:12]]
    rs1 = regs[instruction[12:17]]
    funct3 = instruction[17:20]
    if funct3 == '000':
        if rs1 == rs2:
            regs['PC'] += twos_complement_binary_to_decimal(imm)
    elif funct3 == '001':
        if rs1 != rs2:
            regs['PC'] += twos_complement_binary_to_decimal(imm)
    elif funct3 == '100':
        if rs1 < rs2:
            regs['PC'] += twos_complement_binary_to_decimal(imm)
    elif funct3 == '101':
        if rs1 >= rs2:
            regs['PC'] += twos_complement_binary_to_decimal(imm)
    elif funct3 == '110':
        if rs1 < rs2:
            regs['PC'] += twos_complement_binary_to_decimal(imm)
    elif funct3 == '111':
        if rs1 >= rs2:
            regs['PC'] += twos_complement_binary_to_decimal(imm)

inpt=sys.argv[1]
otpt=sys.argv[2]
pointer1=open(inpt,'r')
pointer2=open(otpt,'w')
lines=pointer1.readlines()

i = 0
while i<len(lines):
    if lines[i][-7:] in rtype:
        r_type(lines[i])
        #Complete this
    elif lines[i][-7:] in itype:
        i_type(lines[i])
        #Complete this
    elif lines[i][-7:] in stype:
        s_type(lines[i])
        #Complete this
    elif lines[i][-7:] in btype:
        b_type(lines[i])
        #Complete this
    elif lines[i][-7:] in utype:
        u_type(lines[i])
    elif lines[i][-7:] in jtype:
        j_type(lines[i])
        continue
    else:
        valid_instructions = False
        print("Error: Invalid Instruction")
        break
    regs["PC"]=i*4
    i+=1
    

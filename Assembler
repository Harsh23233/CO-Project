def binary(n,b):
    n=int(n)
    s=""
    if n>=0:
        while n!=0:
            s+=str(n%2)
            n=n//2
        while len(s)<b:
            s+="0"
    else:
        n*=-1
        while n!=0:
            s+=str(n%2)
            n=n//2
        s+="0"
        sc=""
        check=0
        for i in s:
            if i=="0" and check==0:
                sc+=s
            else:
                check=1
                if i=="0":
                    sc+="1"
                else:
                    sc+="0"
        while len(sc)<b:
            sc+="1"
        s=sc
    return s

utype={"auipc":"0010111","lui":"0110111"}
jtype={"jal":"1101111"}

#Now, i or some variable will be iterating through readlines of the text file
#Therefore, assuming a dummy "i" here
i=str()
#dummy dict for registers
reg={}

labels={}
lines=[]
count=0

j=i.split()
'''
if j[0][-1]!=":":
    j.insert(0,"")
else:
  labels[j[0]]=count
'''

if j[1] in utype:
  op=j[2].split(",")
  line=binary(op[1],20)+reg[op[0]]+utype[j[1]]
  lines.append(line)
elif j[1] in jtype:
  op=j[2].split(",")
  line=binary(op[1],20)+reg[op[0]]+jtype[j[1]]    
  lines.append(line)


#I & S type Instruction
itype = {'lw': ('0000011','010'), 'addi': ('0010011','000'), 'sltiu': ('0010011','011'), 'jalr': ('1100111','000')}
stype = {'sw': ('0100011','010')}
def decimal_to_binary(n, length):
    if -(2 ** (length - 1)) <= n < 2 ** length:      #to check whether input value is in range
        return format(n if n >= 0 else (1 << length) + n, f'0{length}b')
    else:
        return "Invalid instruction" 
def check_arguments(instr, num_args):  #to check if input has req no. of parameters
    if len(instr.split(',')) != num_args:
        return "Invalid Number of Arguments"
    return None
def check_register(reg_name):    #to check if the reg exists
    if reg_name not in reg:
        return "Invalid Register"
    return None

def i_code(x):
    opcode, funct3 = itype[x[0]]
    if x[0] == 'lw':
        error = check_arguments(x[1], 2) or check_register(x[1].split(',')[1][:-1])
        if error:
            return error
        
        imm1 = x[1].split(',')[1][:-1]
        rs1 = x[1].split(',')[1][x[1].index('(') + 1:-1]
        
        imm = decimal_to_binary(int(imm1), 12)
        return str(imm) + str(reg[rs1]) + funct3 + str(reg[x[1].split(',')[0]]) + opcode
    elif x[0] in ['addi', 'sltiu', 'jalr']:
        error = check_arguments(x[1], 3) or check_register(x[1].split(',')[0]) or check_register(x[1].split(',')[1])
        if error:
            return error
        
        imm = decimal_to_binary(int(x[1].split(',')[2]), 12)
        return imm + reg[x[1].split(',')[0]] + funct3 + reg[x[1].split(',')[1]] + opcode
    else:
        return "Invalid Instruction"

def s_code(x):
    error = check_arguments(x[1], 2) or check_register(x[1].split(',')[1][:-1]) or check_register(x[1].split(',')[0])
    if error:
        return error
    
    imm1 = x[1].split(',')[1][:-1]
    rs1 = x[1].split(',')[1][x[1].index('(') + 1:-1]
    
    opcode, funct3 = stype[x[0]]
    imm = decimal_to_binary(int(imm1), 12)
    return imm[:7] + reg[x[1].split(',')[0]] + reg[rs1] + funct3 + imm[7:] + opcode
#end here

#B type instructions
import sys
output=[]
fnct3={
    "beq":'000',
    "bne":'001',
    "blt":'100',
    "bge":'101',
    "bltu":'110',
    "bgeu":'111'
}

register={
    "zero":'00000',
    "ra":'00001',
    "sp":'00010',
    "gp":'00011',
    "tp":'00100',
    "t0":'00101',
    "t1":'00110',
    "t2":'00111',
    "s0":'01000',
    "fp":'01000',
    "s1":'01001',
    "a0":'01010',
    "a1":'01011',
    "a2":'01100',
    "a3":'01101',
    "a4":'01110',
    "a5":'01111',
    "a6":'10000',
    "a7":'10001',
    "s2":'10010',
    "s3":'10011',
    "s4":'10100',
    "s5":'10101',
    "s6":'10110',
    "s7":'10111',
    "s8":'11000',
    "s9":'11001',
    "s10":'11010',
    "s11":'11011',
    "t3":'11100',
    "t4":'11101',
    "t5":'11110',
    "t6":'11111'
}

def decimal_string_to_binary(decimal_string):
    decimal_number = int(decimal_string)  
    binary_string = bin(decimal_number)[2:]
    binary_string = binary_string.zfill(16)
    return binary_string

# for input
lines = [line.strip() for line in sys.stdin.readlines()]
lines = [line for line in lines if line]
lines = [line.split() for line in lines]
lines = [[line[0]] + line[1].split(',') for line in lines]
for line in lines:
    temp = ''
    label = decimal_string_to_binary(line[3])
    imm1 = label[-5:]
    imm2 = label[4:11]
    temp += (imm2 + register[line[2]] + register[line[1]] + fnct3[line[0]] + imm1 + '1100011')
    print(temp)

# end of B type instructions

#R-Type Instructions
def conversion(instruction,rd,rs1,rs2):
    opcode={
            'add':'0110011',
            'sub':'0110011',
            'sll':'0110011',
            'slt':'0110011',
            'sltu':'0110011',
            'xor':'0110011',
            'srl':'0110011',
            'or':'0110011',
            'and':'0110011'
            }
    func3={
            'add':'000',
            'sub':'000',
            'sll':'001',
            'slt':'010',
            'sltu':'011',
            'xor':'100',
            'srl':'101',
            'or':'110',
            'and':'111'
            }
    func7={
            'add':'0000000',
            'sub':'0100000',
            'sll':'0000000',
            'slt':'0000000',
            'sltu':'0000000',
            'xor':'0000000',
            'srl':'0000000',
            'or':'0000000',
            'and':'0000000'
            }
    registers={
                "zero":'00000',
                "ra":'00001',
                "sp":'00010',
                "gp":'00011',
                "tp":'00100',
                "t0":'00101',
                "t1":'00110',
                "t2":'00111',
                "s0":'01000',
                "fp":'01000',
                "s1":'01001',
                "a0":'01010',
                "a1":'01011',
                "a2":'01100',
                "a3":'01101',
                "a4":'01110',
                "a5":'01111',
                "a6":'10000',
                "a7":'10001',
                "s2":'10010',
                "s3":'10011',
                "s4":'10100',
                "s5":'10101',
                "s6":'10110',
                "s7":'10111',
                "s8":'11000',
                "s9":'11001',
                "s10":'11010',
                "s11":'11011',
                "t3":'11100',
                "t4":'11101',
                "t5":'11110',
                "t6":'11111'
            }
    op=opcode[instruction]
    f3=func3[instruction]
    f7=func7[instruction]
    regd=registers[rd]
    reg1=registers[rs1]
    reg2=registers[rs2]
    binary=f7+reg2+reg1+f3+regd+op
    return binary
rtype=['add','sub','sll','slt','sltu','xor','srl','or','and']
file=open("file.txt",'r')
lines=file.readlines()
for i in lines:
    b=i.split()
    if (b[0] in rtype):
        c=b[1].split(',')
        a=conversion(b[0],c[0],c[1],c[2])
        print (a)
file.close()

#end of R-type instructions

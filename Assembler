def binary(n,b):
    n=int(n)
    s=""
    if n>=0:
        while n!=0:
            s+=str(n%2)
            n=n//2
        while len(s)<b:
            s+="0"
    else:
        n*=-1
        while n!=0:
            s+=str(n%2)
            n=n//2
        s+="0"
        sc=""
        check=0
        for i in s:
            if i=="0" and check==0:
                sc+=s
            else:
                check=1
                if i=="0":
                    sc+="1"
                else:
                    sc+="0"
        while len(sc)<b:
            sc+="1"
        s=sc
    return s

utype={"auipc":"0010111","lui":"0110111"}
jtype={"jal":"1101111"}

#Now, i or some variable will be iterating through readlines of the text file
#Therefore, assuming a dummy "i" here
i=str()
#dummy dict for registers
reg={}

labels={}
lines=[]
count=0

j=i.split()
'''
if j[0][-1]!=":":
    j.insert(0,"")
else:
  labels[j[0]]=count
'''

if j[1] in utype:
  op=j[2].split(",")
  line=binary(op[1],20)+reg[op[0]]+utype[j[1]]
  lines.append(line)
elif j[1] in jtype:
  op=j[2].split(",")
  line=binary(op[1],20)+reg[op[0]]+jtype[j[1]]    
  lines.append(line)


#I & S type Instruction
itype = {'lw': '0000011' ,'addi':'0010011' ,'sltiu':'0010011' ,'jalr':'1100111'}
stype = {'sw':'0100011'}
reg = {'sp': '00010', 'ra': '00001', 'a5': '01111', 's1': '01001'}
def decimal_to_binary_12bit(n):
    if n>=-2048 and n<= 2047:
        return format(n if n >= 0 else (1 << 12) + n, '012b')
    else:
        return "Invalid instruction"
def i_code(x):
    opcode, funct3 = itype[x[0]]
    if x[0] == 'lw':
        y = x[1].split(',')
        imm1 = ''
        for char in y[1]:
            if char != '(':
                imm1 += char
            else:
                break
        rs1 = y[1][y[1].index('(') + 1:-1]
        imm = decimal_to_binary_12bit(int(imm1))
        return str(imm) + str(reg[rs1]) + funct3 + str(reg[y[0]]) + opcode
    elif x[0]=='addi' or x[0]=='sltiu' or x[0]=='jalr': 
        y = x[1].split(',')
        imm = decimal_to_binary_12bit(int(y[2]))
        return imm+reg[y[0]]+funct3+reg[y[1]]+opcode
    
    else: 
        return "Invalid instruction"
def s_code(x):
    y = x[1].split(',')
    imm1 = ''
    for char in y[1]:
        if char != '(':
            imm1 += char
        else:
            break
    rs1 = y[1][y[1].index('(') + 1:-1]
    opcode, funct3 = stype['sw']
    imm = decimal_to_binary_12bit(int(imm1))
    return imm[:7] + reg[y[0]] + reg[rs1] + funct3 + imm[7:] + opcode
#end here

#B type instructions
import sys
output=[]
fnct3={
    "beq":'000',
    "bne":'001',
    "blt":'100',
    "bge":'101',
    "bltu":'110',
    "bgeu":'111'
}

register={
    "zero":'00000',
    "ra":'00001',
    "sp":'00010',
    "gp":'00011',
    "tp":'00100',
    "t0":'00101',
    "t1":'00110',
    "t2":'00111',
    "s0":'01000',
    "fp":'01000',
    "s1":'01001',
    "a0":'01010',
    "a1":'01011',
    "a2":'01100',
    "a3":'01101',
    "a4":'01110',
    "a5":'01111',
    "a6":'10000',
    "a7":'10001',
    "s2":'10010',
    "s3":'10011',
    "s4":'10100',
    "s5":'10101',
    "s6":'10110',
    "s7":'10111',
    "s8":'11000',
    "s9":'11001',
    "s10":'11010',
    "s11":'11011',
    "t3":'11100',
    "t4":'11101',
    "t5":'11110',
    "t6":'11111'
}

def decimal_string_to_binary(decimal_string):
    decimal_number = int(decimal_string)  
    binary_string = bin(decimal_number)[2:]
    binary_string = binary_string.zfill(16)
    return binary_string

# for input
lines = [line.strip() for line in sys.stdin.readlines()]
lines = [line for line in lines if line]
lines = [line.split() for line in lines]
lines = [[line[0]] + line[1].split(',') for line in lines]
for line in lines:
    temp = ''
    label = decimal_string_to_binary(line[3])
    imm1 = label[-5:]
    imm2 = label[4:11]
    temp += (imm2 + register[line[2]] + register[line[1]] + fnct3[line[0]] + imm1 + '1100011')
    print(temp)

# end of B type instructions

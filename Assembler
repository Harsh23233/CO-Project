#utype and jtype portion
utype={"auipc":"0010111","lui":"0110111"}
jtype={"jal":"1101111"}

#Dummy readlines
L=[]

#dummy dict for registers
reg={}

labels={}
lines=[]
count=0

#Checking if last line is virutal halt or not
if L[-1]!="beq zero,zero,0":
    print("Error: No Termination of Program")
    L=[]
else:
    #Two loops will be implemented, first here to check for labels and empty lines
    for i in range(len(L)):
        j=L[i].split()
        if j==[]:
            continue
        if j[0][-1]!=":":
            j.insert(0,"")
        else:
            labels[j[0]]=count
        L[i]=j

    #second here to start assemblin
    for j in L:
        if j[1] in utype:
            if len(j)!=3:
                print("Error: Invalid Instruction Syntax")
                L=[]
                break
            op=j[2].split(",")
            if op[0] not in reg:
                print("Error: Invalid Register")
                L=[]
                break
            elif len(op)!=2:
                print("Error: Inavlid Instruction Syntax")
                L=[]
                break
            elif op[1]>(2**19)-1 or op[1]<-(2**19):
                print("Error: Immediate value out of range")
                L=[]
                break
            else:
                line=binary(op[1],20)+reg[op[0]]+utype[j[1]]
                lines.append(line)
        elif j[1] in jtype:
            if len(j)!=3:
                print("Error: Invalid Instruction Syntax")
                L=[]
                break
            op=j[2].split(",")
            if op[0] not in reg:
                print("Error: Invalid Register")
                L=[]
                break
            elif len(op)!=2:
                print("Error: Inavlid Instruction Syntax")
                L=[]
                break
            elif op[1]>(2**19)-1 or op[1]<-(2**19):
                print("Error: Immediate value out of range")
                L=[]
                break
            else:
                line=binary(op[1],20)+reg[op[0]]+jtype[j[1]]
                lines.append(line)
        else:
            print("Error: Invalid Instruction")
            L=[]
            break
#End of u and j type instructions

#I & S type Instruction
itype = {'lw': ('0000011', '010'), 'addi': ('0010011', '000'), 'sltiu': ('0010011', '011'), 'jalr': ('1100111', '000')}
stype = {'sw': ('0100011', '010')}
reg = {'sp': '01000', 'ra': '01001', 's0': '10000', 's1': '10001', 'a0': '10010', 'a1': '10011', 'a2': '10100', 'a3': '10101', 'a4': '10110', 'a5': '10111', 'a6': '11000', 'a7': '11001', 's2': '11010', 's3': '11011', 's4': '11100', 's5': '11101', 's6': '11110', 's7': '11111'}

def decimal_to_binary(n, length):
    return format(n if -(2 ** (length - 1)) <= n < 2 ** length else (1 << length) + n, f'0{length}b')

def check_input_format(line, inst_type):
    if inst_type == 'lw':
        return len(line.split(',')) == 2 and ' ' in line.split(',')[0] and '(' in line.split(',')[1] and ')' in line.split(',')[1]
    elif inst_type in ['addi', 'sltiu', 'jalr']:
        parts = line.split(',')
        return len(parts) == 3 and ' ' in parts[0] and ' ' in parts[1]
    elif inst_type == 'sw':
        parts = line.split(',')
        return len(parts) == 2 and ' ' in parts[0] and '(' in parts[1] and ')' in parts[1]
    return False

def check_register(reg_name):
    return reg_name.split('(')[0].strip() in reg if '(' in reg_name and ')' in reg_name else reg_name in reg

def i_code(x):
    opcode, funct3 = itype[x[0]]
    if x[0] == 'lw':
        rs1, imm1 = x[1].split(',')[1].split('(')[1].split(')')[0].strip(), x[1].split(',')[1].split('(')[0].strip()
        if not all(map(check_register, [rs1, x[1].split(',')[0]])):
            return "Error"
        imm = decimal_to_binary(int(imm1), 12)
        return str(imm) + reg[rs1] + funct3 + reg[x[1].split(',')[0].strip()] + opcode
    elif x[0] in ['addi', 'sltiu', 'jalr']:
        if not all(map(check_register, x[1].split(','))):
            return "Error"
        imm = decimal_to_binary(int(x[1].split(',')[2].strip()), 12)
        return imm + reg[x[1].split(',')[0].strip()] + funct3 + reg[x[1].split(',')[1].strip()] + opcode
    return "Error"

def s_code(x):
    rs1, imm1 = x[1].split(',')[1].split('(')[1].split(')')[0].strip(), x[1].split(',')[1].split('(')[0].strip()
    if not all(map(check_register, [rs1, x[1].split(',')[0]])):
        return "Error"
    imm = decimal_to_binary(int(imm1), 12)
    opcode, funct3 = stype[x[0]]
    return imm[:7] + reg[x[1].split(',')[0].strip()] + reg[rs1] + funct3 + imm[7:] + opcode

lines = ['sw ra,32(sp)', 'lw a5,32(sp)']
output = []
for line in lines:
    inst = line.split()
    if inst[0] in stype and check_input_format(line, 'sw'):
        output.append(s_code(inst))
    elif inst[0] in itype and check_input_format(line, inst[0]):
        output.append(i_code(inst))
    else:
        output.append("Error")
print("Invalid" if "Error" in output else "\n".join(output))
#end here

#B type instructions
import sys
output=[]
fnct3={
    "beq":'000',
    "bne":'001',
    "blt":'100',
    "bge":'101',
    "bltu":'110',
    "bgeu":'111'
}

register={
    "zero":'00000',
    "ra":'00001',
    "sp":'00010',
    "gp":'00011',
    "tp":'00100',
    "t0":'00101',
    "t1":'00110',
    "t2":'00111',
    "s0":'01000',
    "fp":'01000',
    "s1":'01001',
    "a0":'01010',
    "a1":'01011',
    "a2":'01100',
    "a3":'01101',
    "a4":'01110',
    "a5":'01111',
    "a6":'10000',
    "a7":'10001',
    "s2":'10010',
    "s3":'10011',
    "s4":'10100',
    "s5":'10101',
    "s6":'10110',
    "s7":'10111',
    "s8":'11000',
    "s9":'11001',
    "s10":'11010',
    "s11":'11011',
    "t3":'11100',
    "t4":'11101',
    "t5":'11110',
    "t6":'11111'
}

def decimal_string_to_binary(decimal_string):
    decimal_number = int(decimal_string)  
    binary_string = bin(decimal_number)[2:]
    binary_string = binary_string.zfill(16)
    return binary_string

# for input
lines = [line.strip() for line in sys.stdin.readlines()]
lines = [line for line in lines if line]
lines = [line.split() for line in lines]
lines = [[line[0]] + line[1].split(',') for line in lines]
for line in lines:
    temp = ''
    label = decimal_string_to_binary(line[3])
    imm1 = label[-5:]
    imm2 = label[4:11]
    temp += (imm2 + register[line[2]] + register[line[1]] + fnct3[line[0]] + imm1 + '1100011')
    print(temp)

# end of B type instructions

#R-Type Instructions

def conversion(instruction,rd,rs1,rs2):
    opcode= {
            'add':'0110011',
            'sub':'0110011',
            'sll':'0110011',
            'slt':'0110011',
            'sltu':'0110011',
            'xor':'0110011',
            'srl':'0110011',
            'or':'0110011',
            'and':'0110011'
            }
    func3= {
            'add':'000',
            'sub':'000',
            'sll':'001',
            'slt':'010',
            'sltu':'011',
            'xor':'100',
            'srl':'101',
            'or':'110',
            'and':'111'
            }
    func7= {
            'add':'0000000',
            'sub':'0100000',
            'sll':'0000000',
            'slt':'0000000',
            'sltu':'0000000',
            'xor':'0000000',
            'srl':'0000000',
            'or':'0000000',
            'and':'0000000'
            }
    registers= {
                "zero":'00000',
                "ra":'00001',
                "sp":'00010',
                "gp":'00011',
                "tp":'00100',
                "t0":'00101',
                "t1":'00110',
                "t2":'00111',
                "s0":'01000',
                "fp":'01000',
                "s1":'01001',
                "a0":'01010',
                "a1":'01011',
                "a2":'01100',
                "a3":'01101',
                "a4":'01110',
                "a5":'01111',
                "a6":'10000',
                "a7":'10001',
                "s2":'10010',
                "s3":'10011',
                "s4":'10100',
                "s5":'10101',
                "s6":'10110',
                "s7":'10111',
                "s8":'11000',
                "s9":'11001',
                "s10":'11010',
                "s11":'11011',
                "t3":'11100',
                "t4":'11101',
                "t5":'11110',
                "t6":'11111'
                }
    if (rd not in registers or rs1 not in registers or rs2 not in registers):
        global flag
        flag = 1
        return "Invalid register"
    global Result
    op=opcode[instruction]
    f3=func3[instruction]
    f7=func7[instruction]
    regd=registers[rd]
    reg1=registers[rs1]
    reg2=registers[rs2]
    binary=f7+reg2+reg1+f3+regd+op+"\n"
    Result.append(binary)
    
rtype=['add','sub','sll','slt','sltu','xor','srl','or','and']
flag=0
Result=[]
r_file=open("Input_file.txt",'r')
lines=r_file.readlines()
if lines[-1]!="beq zero,zero,0\n":
    print("Virtual Halt not present as the last instruction")
else:
    for i in lines:
        b=i.split()
        if len(b)!=2:
            flag=1
            print("Invalid number of arguments")
            break
        elif (b[0] in rtype):
            c=b[1].split(',')
            if len(c)!=3:
                flag=1
                print("Invalid number of arguments")
                break
            else:
                conversion(b[0],c[0],c[1],c[2])
        #else:
         #   print("Invalid Instruction")
r_file.close()

w_file=open("Output_file.txt",'w')
if flag==0:
    w_file.writelines(Result)
w_file.close()

#end of R-type instructions
